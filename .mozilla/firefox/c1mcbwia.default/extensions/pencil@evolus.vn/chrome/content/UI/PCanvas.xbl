<?xml version="1.0"?>
<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:p="http://www.evolus.vn/Namespace/Pencil"
          >
    <binding id="canvas">
        <implementation>
            <constructor>
            <![CDATA[
                this.xferHelpers = [];
                this.dragObservers = [];
                
                //building the content as: box >> svg
                var thiz = this;

                var box = document.createElementNS(PencilNamespaces.xul, "xul:box");
                this.appendChild(box);
                box2 = document.createElementNS(PencilNamespaces.xul, "xul:box");
                this.firstChild.appendChild(box2);
                this.focusableBox = box2;
                
                this.addEventListener("mousedown", function (event) {
                    var inDrawing = Dom.findUpward(event.originalTarget, function (node) {
                        return (node == box2 || node == thiz.popup || node == thiz.svg);
                    });
                    if (!inDrawing) {
                        thiz.clearSelection();
                        thiz.selectNone();
                    }
                }, false);

                //create the context menu
                this.popup = document.getAnonymousElementByAttribute(this, "aid", "contextPopup");
                this.arrangementMenu = document.getAnonymousElementByAttribute(this, "aid", "arrangementMenu");
                this.arrangementMenu._canvas = this;

                this.popupSeparator = document.getAnonymousElementByAttribute(this, "aid", "contextPopupSeparator");
                var id = "popup" + Math.round(1000 * Math.random());
                this.popup.setAttribute("id", id);
                box2.setAttribute("context", id);

                this.propertyMenuItem = document.getAnonymousElementByAttribute(this, "aid", "propertyMenuItem");
                this.lockingMenuItem = document.getAnonymousElementByAttribute(this, "aid", "lockingMenuItem");

                this.svg = document.createElementNS(PencilNamespaces.svg, "svg:svg");
                this.svg.setAttribute("version", "1.0");

                //FIXME: this will not be hard-coded
                this.width = this.hasAttribute("width") ? parseInt(this.getAttribute("width"), 10) : 780;
                this.height = this.hasAttribute("height") ? parseInt(this.getAttribute("height"), 10) : 600;
                box2.appendChild(this.svg);

                this.topGroup = document.createElementNS(PencilNamespaces.svg, "svg:g");

                var fixTarget = this.topGroup;
                var fixRef = this.svg;

                window.setTimeout(function () {
                    var matrix = fixTarget.getScreenCTM();
                    var dx = matrix.e - Math.floor(matrix.e);
                    var dy = matrix.f - Math.floor(matrix.f);

                    if (dx != 0 || dy != 0) {
                        matrix = fixRef.getScreenCTM();
                        dx = matrix.e - Math.floor(matrix.e);
                        dy = matrix.f - Math.floor(matrix.f);

                        var t = "translate(" + (0 - dx) + "," + (0 - dy) + ")";
                        fixTarget.setAttribute("transform", t);
                    }

                    window.setTimeout(arguments.callee, 1000);
                }, 1000);
                this.svg.appendChild(this.topGroup);

                //create the background layer
                this.bgLayer = document.createElementNS(PencilNamespaces.svg, "svg:g");
                this.bgLayer.setAttributeNS(PencilNamespaces.p, "p:name", "Background");
                var rect = document.createElementNS(PencilNamespaces.svg, "svg:rect");
                rect.setAttribute("x", "0");
                rect.setAttribute("y", "0");
                rect.setAttribute("width", "2000");
                rect.setAttribute("height", "2000");
                rect.setAttribute("style", "fill: #ffffff; stroke: none; fill-opacity: 0;");
                this.bgLayer.appendChild(rect);
                
                //background image
                this.backgroundImage = document.createElementNS(PencilNamespaces.svg, "svg:image");
                this.backgroundImage.setAttribute("x", "0");
                this.backgroundImage.setAttribute("y", "0");
                this.bgLayer.appendChild(this.backgroundImage);
                this.hasBackgroundImage = false;
                
                var rect = document.createElementNS(PencilNamespaces.svg, "svg:rect");
                rect.setAttribute("x", "0");
                rect.setAttribute("y", "0");
                rect.setAttribute("width", "2000");
                rect.setAttribute("height", "2000");
                rect.setAttributeNS(PencilNamespaces.p, "p:name", "BackgroundDimmer");
                this.bgLayer.appendChild(rect);
                

                this.topGroup.appendChild(this.bgLayer);
                
                //create the drawing layer
                this.drawingLayer = document.createElementNS(PencilNamespaces.svg, "svg:g");
                this.topGroup.appendChild(this.drawingLayer);

                //create the control layer
                this.controlLayer = document.createElementNS(PencilNamespaces.svg, "svg:g");
                this.controlLayer.setAttributeNS(PencilNamespaces.p, "p:type", "ControlLayer");
                
                this.topGroup.appendChild(this.controlLayer);

                this.selectionContainer = document.createElementNS(PencilNamespaces.svg, "svg:g");
                this.selectionContainer.setAttribute("id", "selectionContainer");
                this.installControlSVGElement(this.selectionContainer);
                
                this.rangeBoundRect = document.createElementNS(PencilNamespaces.svg, "svg:rect");
                this.installControlSVGElement(this.rangeBoundRect);
                Svg.setX(this.rangeBoundRect, 0.5);
                Svg.setY(this.rangeBoundRect, 0.5);
                Svg.setWidth(this.rangeBoundRect, 100);
                Svg.setHeight(this.rangeBoundRect, 100);
                this.rangeBoundRect.setAttributeNS(PencilNamespaces.p, "p:type", "RangeBound");

                this.idSeed = 1;

                this.onScreenEditors = [];


                //register event handler
                this.svg.addEventListener("click", function (event) {
                    thiz.handleClick(event);
                }, false);
                this.svg.addEventListener("mousedown", function (event) {
                    thiz.handleMouseDown(event);
                }, false);
                this.svg.ownerDocument.addEventListener("mouseup", function (event) {
                    if (!thiz || !thiz.handleMouseUp) {
                        document.removeEventListener("mouseup", arguments.callee, false);
                        return;
                     }
                    thiz.handleMouseUp(event);
                }, false);
                this.svg.ownerDocument.addEventListener("mousemove", function (event) {
                    if (!thiz || !thiz.handleMouseMove) {
                        document.removeEventListener("mousemove", arguments.callee, false);
                        return;
                    }
                    thiz.handleMouseMove(event);
                }, false);
                this.firstChild.addEventListener("keypress", function (event) {
                    thiz.handleKeyPress(event);
                }, false);

                this.propertyMenuItem.addEventListener("command", function(event) {
                    thiz.handlePropertyMenuItemCommand(event);
                }, false);

                box2.addEventListener("contextmenu", function (event) {
                    thiz.handleContextMenuShow(event);
                }, false);

                this.svg.addEventListener("dblclick", function (event) {
                    thiz.handleDblclick(event);
                }, false);
                
                this.careTaker = new CanvasCareTaker(this);
                
                /*
                this.dragObserver = {
                    getSupportedFlavours : function () {
                        var flavours = new FlavourSet();
                        
                        flavours.appendFlavour("pencil/def");
                        flavours.appendFlavour("text/unicode");
                        //flavours.appendFlavour("image/png");
                        
                        return flavours;
                    },
                    onDragOver: function (evt, flavour, session){},
                    onDrop: function (evt, transferData, session) {
                        netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                        var defId = transferData.data;
                        var def = CollectionManager.shapeDefinition.locateDefinition(defId);
                        
                        var loc = thiz.getEventLocation(evt);
                        
                        if (loc.x <0 || loc.y < 0) return;
                        
                        thiz.insertShape(def, new Bound(loc.x, loc.y, null, null));
                    }
                };
                */
                
                this.nVGridPainted = 0;
                this.nHGridPainted = 0;


                this.zoomTo(1);

            ]]>
            </constructor>
            <method name="getEventLocation">
                <parameter name="event"/>
                <body>
                <![CDATA[
                        var rect = this.svg.getBoundingClientRect();
                        var x = Math.round(event.clientX - rect.left);
                        var y = Math.round(event.clientY - rect.top);
                        
                        return {x: x, y: y};
                ]]>
                </body>
            </method>
            <method name="addToSelection">
                <parameter name="target"/>
                <body>
                <![CDATA[
                    var rect = document.createElementNS(PencilNamespaces.svg, "svg:rect");
                    this.selectionContainer.appendChild(rect);
                    rect._target = target;

                    this._invalidateOneSelection(rect);
                ]]>
                </body>
            </method>
            <method name="_invalidateOneSelection">
                <parameter name="rect"/>
                <body>
                <![CDATA[
                    var bbox = rect._target.getBoundingRect();
                    Svg.setX(rect, Math.round(bbox.x));
                    Svg.setY(rect, Math.round(bbox.y));
                    Svg.setWidth(rect, Math.round(bbox.width));
                    Svg.setHeight(rect, Math.round(bbox.height));
                ]]>
                </body>
            </method>
            <method name="_sayTargetChanged">
                <body>
                <![CDATA[
                    Dom.emitEvent("p:TargetChanged", this, {canvas: this});
                ]]>
                </body>
            </method>
            <method name="getSelectedTargets">
                <body>
                <![CDATA[
                    var targets = [];
                    for (var i = 0; i < this.selectionContainer.childNodes.length; i ++) {
                        var rect = this.selectionContainer.childNodes[i];
                        if (rect._target) targets.push(rect._target);
                    }

                    return targets;
                ]]>
                </body>
            </method>
            <method name="clearSelection">
                <body>
                <![CDATA[
                    while (this.selectionContainer.hasChildNodes()) {
                        this.selectionContainer.removeChild(this.selectionContainer.firstChild);
                    }
                ]]>
                </body>
            </method>
            <method name="selectAll">
                <body>
                <![CDATA[
                    this.clearSelection();
                    var thiz = this;
                    Dom.workOn("./svg:g[@p:type]", this.drawingLayer, function (node) {
                        if (thiz.isShapeLocked(node)) return;
                        try {
                            var controller = thiz.createControllerFor(node);
                            thiz.addToSelection(controller);
                        } catch (e) {
                            //alert(e);
                        }
                    });

                    var targets = this.getSelectedTargets();
                    this.setAttributeNS(PencilNamespaces.p, "p:selection", targets.length);
                    
                    var controller = null;
                    if (targets.length > 1) {
                        controller = new TargetSet(this, targets);
                    } else if (targets.length == 1 && controller == null) {
                        controller = targets[0];
                    }
                    
                    this._detachEditors();
                    this.currentController = controller;
                    
                    this._attachEditors(this.currentController);
                    this._sayTargetChanged();
                ]]>
                </body>
            </method>
            <method name="removeFromSelection">
                <parameter name="target"/>
                <body>
                <![CDATA[
                    var foundRect = null;
                    for (var i = 0; i < this.selectionContainer.childNodes.length; i ++) {
                        var rect = this.selectionContainer.childNodes[i];
                        if (rect._target == target) {
                            foundRect = rect;
                            break;
                        }
                    }
                    if (foundRect) this.selectionContainer.removeChild(foundRect);
                ]]>
                </body>
            </method>

            <method name="insertObject">
                <parameter name="obj"/>
                <body>
                <![CDATA[
                    this.drawingLayer.appendChild(obj);
                ]]>
                </body>
            </method>
            <method name="installControlSVGElement">
                <parameter name="obj"/>
                <body>
                <![CDATA[
                    this.controlLayer.appendChild(obj);
                ]]>
                </body>
            </method>
            <method name="zoomTo">
                <parameter name="factor"/>
                <body>
                <![CDATA[
                    this.zoom = factor;
                    this.drawingLayer.setAttribute("transform", "scale(" + [this.zoom, this.zoom] + ")");
                    this.svg.setAttribute("width", Math.ceil(this.width * this.zoom));
                    this.svg.setAttribute("height", Math.ceil(this.height * this.zoom));
                    this.backgroundImage.setAttribute("transform", "scale(" + [this.zoom, this.zoom] + ")");
                    CanvasImpl.setupGrid.apply(this);

                    this.invalidateEditors();
                ]]>
                </body>
            </method>
            <method name="getZoomedGeo">
                <parameter name="target"/>
                <body>
                <![CDATA[
                    if (!target) return null;
                    var geo = target.getGeometry();
                    geo = geo.clone(this.svg);
                    geo.ctm.e *= this.zoom;
                    geo.ctm.f *= this.zoom;
                    geo.dim.w *= this.zoom;
                    geo.dim.h *= this.zoom;
                    
                    if (geo.loc) {
                        geo.loc.x *= this.zoom;
                        geo.loc.y *= this.zoom;
                    }

                    return geo;
                ]]>
                </body>
            </method>
            <method name="getZoomedRect">
                <parameter name="rect"/>
                <body>
                <![CDATA[
                    rect.x *= this.zoom;
                    rect.y *= this.zoom;
                    rect.width *= this.zoom;
                    rect.height *= this.zoom;

                    return rect;
                ]]>
                </body>
            </method>
            <method name="setZoomedGeo">
                <parameter name="target"/>
                <parameter name="geo"/>
                <body>
                <![CDATA[
                    geo = geo.clone(this.svg);
                    geo.ctm.e /= this.zoom;
                    geo.ctm.f /= this.zoom;
                    geo.dim.w /= this.zoom;
                    geo.dim.h /= this.zoom;
                    
                    this.run(function() {
                        target.setGeometry(geo);
                    }, this);
                ]]>
                </body>
            </method>
            <method name="redraw">
                <body>
                <![CDATA[
                    this.drawingLayer.ownerSVGElement.forceRedraw();
                ]]>
                </body>
            </method>
            <method name="getType">
                <parameter name="svg"/>
                <body>
                <![CDATA[
                    return svg.getAttributeNS(PencilNamespaces.p, "def");
                ]]>
                </body>
            </method>
            <method name="insertShape">
                <parameter name="shapeDef"/>
                <parameter name="bound"/>
                <body>
                <![CDATA[
                    this.run(this.insertShapeImpl_, this, [shapeDef, bound ? bound : null]);
                ]]>
                </body>
            </method>
            <method name="insertShapeImpl_">
                <parameter name="shapeDef"/>
                <parameter name="bound"/>
                <body>
                <![CDATA[
                    // instantiate the shape using the shapedef
                    var shape = this.ownerDocument.createElementNS(PencilNamespaces.svg, "g");
                    shape.setAttributeNS(PencilNamespaces.p, "p:type", "Shape");
                    shape.setAttributeNS(PencilNamespaces.p, "p:def", shapeDef.id);

                    shape.appendChild(this.ownerDocument.createElementNS(PencilNamespaces.p, "p:metadata"));

                    for (var i = 0; i < shapeDef.contentNode.childNodes.length; i ++) {
                        shape.appendChild(this.ownerDocument.importNode(shapeDef.contentNode.childNodes[i], true));
                    }


                    //generate the ids
                    var seed = "" + (this.idSeed ++) + (new Date().getTime());

                    Dom.workOn(".//*[@p:name]", shape, function (node) {
                        var id = node.getAttributeNS(PencilNamespaces.p, "name") + seed;
                        node.setAttribute("id", id);
                        node.id = id;
                    });
                    
                    Dom.resolveIdRef(shape, seed);


                    // add the newly created shape into the drawing layer
                    this.drawingLayer.appendChild(shape);

                    // applying defined behaviors into the shape

                    var controller = new Shape(this, shape);
                    controller.setInitialPropertyValues();
                    
                    if (bound) {
                        var bbox = controller.getBoundingRect();
                        controller.moveBy(bound.x - Math.round(bbox.width / 2), bound.y - Math.round(bbox.height / 2), true);
                        controller.normalizePositionToGrid();
                    }
                    
                    this.selectShape(shape);
                ]]>
                </body>
            </method>
            <method name="selectShape">
                <parameter name="shape"/>
                <body>
                <![CDATA[
                    if (this.isShapeLocked(shape)) return;
                    var controller = this.createControllerFor(shape);

                    this.currentController = controller;
                    this.clearSelection();
                    this.addToSelection(this.currentController);
                    this.setAttributeNS(PencilNamespaces.p, "p:selection", 1);

                    this.lastTop = shape;
                    this.hasMoved = true;

                    this.focus();

                    this._attachEditors(controller);

                    this._sayTargetChanged();
                ]]>
                </body>
            </method>
            <method name="selectMultiple">
                <parameter name="shapes"/>
                <body>
                <![CDATA[
                    this.clearSelection();
                    for (i in shapes) {
                        if (this.isShapeLocked(shapes[i])) continue;
                        this.addToSelection(this.createControllerFor(shapes[i]));
                    }
                    this.setAttributeNS(PencilNamespaces.p, "p:selection", shapes.length);
                    
                    var targets = this.getSelectedTargets();
                    if (targets.length > 1) {
                        controller = new TargetSet(this, targets);
                    } else if (targets.length == 1 && controller == null) {
                        controller = targets[0];
                    }


                    this.currentController = controller;

                    this.lastTop = null;
                    this.hasMoved = true;

                    this.focus();

                    this._attachEditors(controller);

                    this._sayTargetChanged();
                ]]>
                </body>
            </method>
            <method name="selectNone">
                <body>
                <![CDATA[
                    this.clearSelection();
                    this._detachEditors();
                    this.currentController = null;

                    this.lastTop = null;
                    this.hasMoved = true;

                    this.focus();
                    this._sayTargetChanged();
                ]]>
                </body>
            </method>
            <method name="createControllerFor">
                <parameter name="top"/>
                <body>
                <![CDATA[
                    var type = top.getAttributeNS(PencilNamespaces.p, "type");
                    if (type == "Shape") {
                        try {
                            return new Shape(this, top);
                        } catch (e) {}
                    } else if (type == "Group") {
                        return new Group(this, top);
                    }
                    return new Null(this, top);
                ]]>
                </body>
            </method>
            <method name="_detachEditors">
                <body>
                <![CDATA[
                    for (editor in this.onScreenEditors) this.onScreenEditors[editor].dettach();
                    if (this.propertyPageEditor && this.propertyPageEditor.dettach) this.propertyPageEditor.dettach();
                    if (this.contextMenuEditor && this.contextMenuEditor.dettach) this.contextMenuEditor.dettach();
                ]]>
                </body>
            </method>
            <method name="passivateEditors">
                <body>
                <![CDATA[
                    for (editor in this.onScreenEditors) this.onScreenEditors[editor].passivated = true;
                    if (this.propertyPageEditor) this.propertyPageEditor.passivated = true;
                    if (this.contextMenuEditor) this.contextMenuEditor.passivated = true;
                ]]>
                </body>
            </method>
            <method name="_attachEditors">
                <parameter name="controller"/>
                <body>
                <![CDATA[
                    for (editor in this.onScreenEditors) this.onScreenEditors[editor].attach(controller);
                    if (this.propertyPageEditor && this.propertyPageEditor.attach) this.propertyPageEditor.attach(controller);
                    //if (this.contextMenuEditor && this.contextMenuEditor.attach) this.contextMenuEditor.attach(controller);
                ]]>
                </body>
            </method>

            <method name="handleMouseDown">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    tick("begin");
                    
                    this._button = event.button;
                    var thiz = this;
                    var isInControlLayer = Dom.findUpward(event.originalTarget, function (node) {
                        return (node == thiz.controlLayer);
                    });
                    if (isInControlLayer) return;

                    var top = Dom.findTop(event.originalTarget, function (node) {
                        return node.hasAttributeNS && node.hasAttributeNS(PencilNamespaces.p, "type");
                    });
                    if (top && this.isShapeLocked(top)) top = null;
                    if (!top) {
                        this.lastTop = null;
                        //this.clearSelection();
                        //this._detachEditors();
                        this.currentController = null;
                        //this.setAttributeNS(PencilNamespaces.p, "p:selection", 0);
                        
                        this.isSelectingRange = true;
                        this.lastMousePos = this.getEventLocation(event);
                        this.setRangeBoundStart(this.lastMousePos.x, this.lastMousePos.y);
                        this.setRangeBoundVisibility(true);
                        this.setRangeBoundSize(0, 0);
                        this.currentRange = {w: this.lastMousePos.x, y: this.lastMousePos.y, width: 0, height: 0};

                        this._sayTargetChanged();
                        return;
                    }
                    tick("top found");

                    var controller = null;

                    var targets = this.getSelectedTargets();
                    var foundTarget = null;
                    for (i in targets) {
                        var target = targets[i];
                        if (target.isFor(top)) {
                            foundTarget = target;
                            break;
                        }
                    }
                    if (event.ctrlKey) {
                        if (foundTarget) {
                            this.removeFromSelection(foundTarget);
                        } else {
                            var newController = this.createControllerFor(top);
                            this.addToSelection(newController);
                        }
                    } else {
                        if (!foundTarget || targets.length == 1) {
                            this.clearSelection();
                            controller = this.createControllerFor(top);
                            this.addToSelection(controller);
                        }
                    }
                    tick("target setup");
                    
                    var targets = this.getSelectedTargets();
                    if (targets.length > 1) {
                        controller = new TargetSet(this, targets);
                    } else if (targets.length == 1 && controller == null) {
                        controller = targets[0];
                    }

                    this.setAttributeNS(PencilNamespaces.p, "p:selection", targets.length);


                    if (controller) {
                        this.currentController = controller;
                        this.controllerHeld = true;

                        this.oX = Math.round(event.clientX / this.zoom);
                        this.oY = Math.round(event.clientY / this.zoom);
                        this.oldPos = this.currentController.getGeometry();
                        
                        tick("before setPositionSnapshot");
                        this.currentController.setPositionSnapshot();
                        tick("after setPositionSnapshot");
                        
                        this.setAttributeNS(PencilNamespaces.p, "p:holding", "true");

                        if (top != this.lastTop || event.ctrlKey || event.button != 0) {
                            this.reClick = false;
                            this._attachEditors(controller);


                        } else {
                            this.reClick = true;
                        }
                        tick("attached");

                        this.hasMoved = false;
                        this.lastTop = top;
                        this._sayTargetChanged();
                        tick("done");
                    }
                ]]>
                </body>
            </method>
            <method name="handleMouseUp">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    if (this.reClick && !this.hasMoved) {
                        for (editor in this.onScreenEditors) this.onScreenEditors[editor].nextTool();
                    }
                    if (this.controllerHeld && this.currentController && this.currentController.markAsMoving) {
                        this.currentController.markAsMoving(false);
                        this.currentController.clearPositionSnapshot();
                        this.invalidateEditors();
                    }
                    if (this.controllerHeld && this.hasMoved) {
                        //just to save state
                        this.run(function() {}, this);
                    }
                    
                    this.removeAttributeNS(PencilNamespaces.p, "holding");
                    
                    this.reClick = false;
                    this.hasMoved = true;
                    
                    this.controllerHeld = false;
                    
                    if (this.isSelectingRange) {
                        this.setRangeBoundVisibility(false);
                        this.isSelectingRange = false;
                        //enum objects that are in range
                        if (!event.ctrlKey) {
                            this.clearSelection();
                        }
                        var thiz = this;
                        Dom.workOn("./svg:g[@p:type]", this.drawingLayer, function (node) {
                            if (thiz.isShapeLocked(node)) return;
                            var controller = thiz.createControllerFor(node);
                            var bbox = controller.getBoundingRect();
                            
                            if (Svg.isInside(bbox, thiz.currentRange)) {
                                if (event.ctrlKey) {
                                    var targets = thiz.getSelectedTargets();
                                    var foundTarget = null;
                                    for (i in targets) {
                                        var target = targets[i];
                                        if (target.isFor(node)) {
                                            foundTarget = target;
                                            break;
                                        }
                                    }
                                    
                                    if (foundTarget) {
                                        thiz.removeFromSelection(foundTarget);
                                    } else {
                                        var target = thiz.createControllerFor(node);
                                        thiz.addToSelection(target);
                                    }
                                } else {
                                    var target = thiz.createControllerFor(node);
                                    thiz.addToSelection(target);
                                }
                            }
                        });
                        var controller = null;
                        var targets = this.getSelectedTargets();
                        this.setAttributeNS(PencilNamespaces.p, "p:selection", targets.length);
                        
                        if (targets.length > 1) {
                            controller = new TargetSet(this, targets);
                        } else if (targets.length == 1 && controller == null) {
                            controller = targets[0];
                        }
                        
                        this._detachEditors();
                        if (controller) {
                            this.currentController = controller;
                            this._attachEditors(this.currentController);
                        }
                        this.currentRange = null;
                        this._sayTargetChanged();
                    }
                ]]>
                </body>
            </method>
            <method name="handleClick">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    //is it from an html:a?
                    var a = Dom.findUpward(event.originalTarget, function (node) {
                        return (node && node.nodeType == 1
                                     && node.localName.toLowerCase() == "a"
                                     && node.namespaceURI == PencilNamespaces.html);
                    });
                    
                    if (!a) return;
                    
                    //is this html:a inside an svg:foreignObject?
                    var foreignObject = Dom.findUpward(a, function (node) {
                        return (node && node.nodeType == 1
                                     && node.localName == "foreignObject"
                                     && node.namespaceURI == PencilNamespaces.svg);
                    });
                    
                    //ok, it is then prevent it
                    if (foreignObject) {
                        event.preventDefault();
                        event.cancelBubble = true;
                    }
                ]]>
                </body>
            </method>
            <method name="handleMouseMove">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    if (this._button != 0) return;
                    event.preventDefault();
                    event.stopPropagation();
                    
                    if (this.controllerHeld && this.currentController) {
                        tick("start");
                        if (this.currentController.markAsMoving) this.currentController.markAsMoving(true);
                        tick("after mark");
                        var newX = Math.round(event.clientX / this.zoom);
                        var newY = Math.round(event.clientY / this.zoom);

                        var dx = newX - this.oX;
                        var dy = newY - this.oY;

                        //this.oX = newX;
                        //this.oY = newY;
                        
                        this.hasMoved = true;
                        this.currentController.moveFromSnapshot(dx, dy);
                        tick("after move");
                        return;
                    }
                    
                    if (this.isSelectingRange) {
                        var end = this.getEventLocation(event);
                        var x1 = Math.min(end.x, this.lastMousePos.x);
                        var x2 = Math.max(end.x, this.lastMousePos.x);
                        var y1 = Math.min(end.y, this.lastMousePos.y);
                        var y2 = Math.max(end.y, this.lastMousePos.y);
                        
                        var w = x2 - x1;
                        var h = y2 - y1;
                        
                        this.currentRange = {x: x1, y: y1, width: w, height: h};
                        
                        this.setRangeBoundStart(x1, y1);
                        this.setRangeBoundSize(w, h);
                    }
                ]]>
                </body>
            </method>
            <method name="setRangeBoundStart">
                <parameter name="x"/>
                <parameter name="y"/>
                <body>
                <![CDATA[
                    Svg.setX(this.rangeBoundRect, x + 0.5);
                    Svg.setY(this.rangeBoundRect, y + 0.5);
                ]]>
                </body>
            </method>
            <method name="setRangeBoundSize">
                <parameter name="w"/>
                <parameter name="h"/>
                <body>
                <![CDATA[
                    Svg.setWidth(this.rangeBoundRect, w);
                    Svg.setHeight(this.rangeBoundRect, h);
                ]]>
                </body>
            </method>
            <method name="setRangeBoundVisibility">
                <parameter name="visible"/>
                <body>
                <![CDATA[
                    this.rangeBoundRect.setAttributeNS(PencilNamespaces.p, "p:on", visible ? "true" : "false");
                ]]>
                </body>
            </method>
            <method name="handleKeyPress">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    if (event.keyCode == event.DOM_VK_UP ||
                        event.keyCode == event.DOM_VK_DOWN ||
                        event.keyCode == event.DOM_VK_LEFT ||
                        event.keyCode == event.DOM_VK_RIGHT
                        ) {
                        event.preventDefault();
                        if (!this.currentController) return;

                        var dx = 0;
                        var dy = 0;

                        if (event.keyCode == event.DOM_VK_UP) dy = -1;
                        if (event.keyCode == event.DOM_VK_DOWN) dy = 1;
                        if (event.keyCode == event.DOM_VK_LEFT) dx = -1;
                        if (event.keyCode == event.DOM_VK_RIGHT) dx = 1;
                        
                        var gridSize = Pencil.getGridSize();
                        if (event.shiftKey) {
                            dx *= gridSize.w * 4;
                            dy *= gridSize.h * 4;
                        } else if (event.ctrlKey) {
                            dx *= gridSize.w;
                            dy *= gridSize.h;
                        }


                        this.run(function () {
                            this.currentController.moveBy(dx, dy);
                        }, this);
                        
                        this.invalidateEditors();
                        event.preventDefault();
                    } else if (event.keyCode == event.DOM_VK_DELETE) {
                        if (this.currentController) {
                            this.run(function () {
                                this.currentController.deleteTarget();
                            }, this);
                            this.currentController = null;
                            this._detachEditors();
                            this.clearSelection();
                            this._sayTargetChanged();
                            event.preventDefault();
                        }
                    } else if (event.keyCode == event.DOM_VK_F2) {
                        if (this.currentController) {
                            Dom.emitEvent("p:TextEditingRequested", event.originalTarget, {controller: this.currentController});
                        }
                    } else if (event.charCode == " ".charCodeAt(0) && event.ctrlKey) {
                        event.preventDefault();
                        this._showPropertyDialog();
                        event.preventDefault();
                    } else if (event.charCode == "a".charCodeAt(0) && event.ctrlKey) {
                        event.preventDefault();
                        this.selectAll();
                        event.preventDefault();
                    }

                ]]>
                </body>
            </method>
            <method name="handleContextMenuShow">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    try {
                        Dom.workOn("./xul:menuseparator", this.popup, function (sep) {
                            sep.style.display = "";
                        });
                        for (var i = 0; i < this.popup.childNodes.length; i ++) {
                            var child = this.popup.childNodes[i];
                            var forAtt = child.getAttributeNS(PencilNamespaces.p, "for");
                            child._canvas = this;
                            if (forAtt) {
                                forAtt = "," + forAtt + ",";
                                var visible = false;
                                if (this.currentController) {
                                    if (forAtt.indexOf("," + this.currentController.constructor.name + ",") >= 0) {
                                        visible = true;
                                    }
                                }

                                child.style.display = visible ? "" : "none";
                                child._controller = this.currentController;
                            }
                        }
                        
                        
                        this.lockingMenuItem.style.display = "none";
                        this.lockingStatus = null;
                        
                        if (this.currentController) {
                            this.lockingStatus = {
                                controller: this.currentController
                            };
                            this.lockingMenuItem.style.display = "";
                            this.lockingMenuItem.setAttribute("checked", "false");
                        } else {
                            var top = Dom.findTop(event.originalTarget, function (node) {
                                return node.hasAttributeNS && node.hasAttributeNS(PencilNamespaces.p, "type");
                            });
                            if (top && this.isShapeLocked(top)) {
                                this.lockingStatus = {
                                    node: top
                                };
                                this.lockingMenuItem.style.display = "";
                                this.lockingMenuItem.setAttribute("checked", "true");
                            }
                        }
                        
                        //remove all menu items previously created by the on-menu editor
                        var parent = this.popupSeparator.parentNode;
                        var len = parent.childNodes.length;
                        for (var i = len - 1; i >= 0; i --) {
                            var child = parent.childNodes[i];
                            if (child._isEditor) parent.removeChild(child);
                        }

                        if (this.currentController) {
                            //attach now
                            if (this.contextMenuEditor) {
                                this.contextMenuEditor.attach(this.currentController);
                            }
                        }
                        
                        var childs = this.popup.childNodes;
                        var shouldHideNextSeparator = true;
                        var foundVisibleItem = false;
                        
                        for (var i = 0; i < childs.length; i ++) {
                            var child = childs[i];
                            if (child.localName == "menuseparator") {
                                if (shouldHideNextSeparator) {
                                    child.style.display = "none";
                                } else {
                                    shouldHideNextSeparator = false;
                                }
                            } else {
                                if (child.style.display != "none") {
                                    shouldHideNextSeparator = false;
                                }
                            }
                            
                            if (child.style.display != "none") {
                                foundVisibleItem = true;
                            }
                        }
                        
                        for (var i = childs.length - 1; i >= 0; i --) {
                            var child = childs[i];
                            if (child.localName != "menuseparator" && child.style.display != "none") {
                                break;
                            }
                            child.style.display = "none";
                        }
                        if (!foundVisibleItem) {
                            this.popup.hidePopup();
                            return;
                        }
                    } catch (e) {
                        Console.dumpError(e);
                    }                        
                ]]>
                </body>
            </method>
            <method name="insertEditorContextMenuItem">
                <parameter name="menuItem"/>
                <body>
                <![CDATA[
                    var parent = this.popupSeparator.parentNode;
                    menuItem._isEditor = true;

                    parent.insertBefore(menuItem, this.popupSeparator);
                ]]>
                </body>
            </method>
            <method name="invalidateEditors">
                <parameter name="source"/>
                <body>
                <![CDATA[
                    for (editor in this.onScreenEditors) {
                        var e = this.onScreenEditors[editor];
                        if (!source || source != e) e.invalidate();
                    }
                    //invalidates all selections
                    for (var i = 0; i < this.selectionContainer.childNodes.length; i ++) {
                        var rect = this.selectionContainer.childNodes[i];
                        this._invalidateOneSelection(rect);
                    }

                ]]>
                </body>
            </method>
            <method name="_showPropertyDialog">
                <body>
                <![CDATA[
                    if (this.propertyPageEditor && this.currentController) {
                        this.propertyPageEditor.showAndAttach(this.currentController);
                    }
                ]]>
                </body>
            </method>
            <method name="handlePropertyMenuItemCommand">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    this._showPropertyDialog();
                ]]>
                </body>
            </method>
            <method name="handleDblclick">
                <parameter name="event"/>
                <body>
                <![CDATA[
                    //find the top, get the def
                    var thiz = this;
                    var top = Dom.findTop(event.originalTarget, function (node) {
                        return node.hasAttributeNS && node.hasAttributeNS(PencilNamespaces.p, "type") && node.getAttributeNS(PencilNamespaces.p, "type") == "Shape" && !thiz.isShapeLocked(node);
                    });
                    
                    if (!top) return;
                    
                    var target = this.createControllerFor(top);
                    
                    Dom.emitEvent("p:ShapeDoubleClicked", top, {controller: target});
                    
                ]]>
                </body>
            </method>
            <method name="focus">
                <body>
                <![CDATA[
                    this.focusableBox.focus();
                ]]>
                </body>
            </method>
            <method name="doCopy">
                <body>
                <![CDATA[
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                    if (!this.currentController) return;
                    
                    var transferableData = this.currentController.createTransferableData();

                    //serialize to string
                    var textualData = new XMLSerializer().serializeToString(transferableData.dataNode);
                    
                    var systemString   = Components.classes["@mozilla.org/supports-string;1"].
                                           createInstance(Components.interfaces.nsISupportsString);
                    if (!systemString) return false;
                    systemString.data  = textualData;

                    var trans = Components.classes["@mozilla.org/widget/transferable;1"].
                                           createInstance(Components.interfaces.nsITransferable);
                    if (!trans) return false;

                    //trans.addDataFlavor("text/unicode");
                    //trans.setTransferData("text/unicode", systemString, textualData.length * 2);

                    trans.addDataFlavor(transferableData.type);
                    trans.setTransferData(transferableData.type, systemString, textualData.length * 2);
                    
                    try {
                        //generating text/xml+svg
                        if (transferableData.isSVG) {
                            var svg = this.svg.ownerDocument.createElementNS(PencilNamespaces.svg, "svg");
                            
                            //svg.setAttribute("width", transferableData.svgDIM.w);
                            //svg.setAttribute("height", transferableData.svgDIM.h);
                            svg.appendChild(transferableData.dataNode);
                            
                            var svgXML = new XMLSerializer().serializeToString(svg);
                            svgXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + svgXML;
                            
                            var svgXMLSS   = Components.classes["@mozilla.org/supports-string;1"].
                                                   createInstance(Components.interfaces.nsISupportsString);
                            if (!svgXMLSS) return false;
                            svgXMLSS.data = svgXML;
                            
                            trans.addDataFlavor("image/svg+xml");
                            trans.setTransferData("image/svg+xml", svgXMLSS, svgXML.length * 2);
                        }
                    } catch (e) {
                        Console.dumpError(e);
                    }

                    var clipId = Components.interfaces.nsIClipboard;
                    var clip   = Components.classes["@mozilla.org/widget/clipboard;1"].getService(clipId);
                    if (!clip) return false;

                    clip.setData(trans, null, clipId.kGlobalClipboard);
                ]]>
                </body>
            </method>
            <method name="doPaste">
                <body>
                <![CDATA[
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                    var clip  = Components.classes["@mozilla.org/widget/clipboard;1"].getService(Components.interfaces.nsIClipboard);
                    if (!clip) return false;

                    for (i in this.xferHelpers) {
                        var helper = this.xferHelpers[i];
                        var trans = Components.classes["@mozilla.org/widget/transferable;1"].createInstance(Components.interfaces.nsITransferable);
                        if (!trans) return;
                        
                        trans.addDataFlavor(helper.type);
                        clip.getData(trans, clip.kGlobalClipboard);

                        var data = new Object();
                        var length = new Object();
                        var flavour = new Object();
                        
                        try {
                            trans.getAnyTransferData(flavour, data, length);
                        } catch (e) {
                            continue;
                        }
                        
                        if (data && length && data.value && length.value) {
                            helper.handleData(data.value, length.value);
                            break;
                        }
                    }

                ]]>
                </body>
            </method>
            <method name="doGroup">
                <body>
                <![CDATA[
                    this.run(this.doGroupImpl_, this);
                ]]>
                </body>
            </method>
            <method name="doGroupImpl_">
                <body>
                <![CDATA[
                    var targets = this.getSelectedTargets();
                    if (targets.length <= 1) return;
                    
                    //create an svg:g to box all the selected target
                    var g = this.ownerDocument.createElementNS(PencilNamespaces.svg, "g");
                    g.setAttributeNS(PencilNamespaces.p, "p:type", "Group");
                    
                    var nodes = [];
                    Dom.workOn("./svg:g[@p:type]", this.drawingLayer, function (node) {
                        for (t in targets) if (targets[t].isFor(node)) nodes.push(node);
                    });
                    
                    for (n in nodes) {
                        var node = nodes[n];
                        node.parentNode.removeChild(node);
                        g.appendChild(node);
                    }
                    
                    this.drawingLayer.appendChild(g);
                    
                    this.selectShape(g);
                ]]>
                </body>
            </method>
            <method name="ensureControllerInView">
                <body>
                <![CDATA[
                ]]>
                </body>
            </method>
            <method name="doUnGroup">
                <body>
                <![CDATA[
                    this.run(this.doUnGroupImpl_, this);
                ]]>
                </body>
            </method>
            <method name="doUnGroupImpl_">
                <body>
                <![CDATA[
                    if (!this.currentController) return;
                    if (this.currentController.constructor != Group) return;
                    
                    var nodes = [];
                    for (t in this.currentController.targets) {
                        var node = this.currentController.targets[t].svg;
                        node.parentNode.removeChild(node);
                        this.drawingLayer.appendChild(node);
                        
                        nodes.push(node);
                    }
                    
                    this.drawingLayer.removeChild(this.currentController.svg);
                    
                    this.selectMultiple(nodes);
                ]]>
                </body>
            </method>
            <method name="isShapeLocked">
                <parameter name="shape"/>
                <body>
                <![CDATA[
                    return shape.getAttributeNS(PencilNamespaces.p, "locked") == "true";
                ]]>
                </body>
            </method>
            <method name="toggleLocking">
                <body>
                <![CDATA[
                    this.run(this.toggleLockingImpl_, this);
                ]]>
                </body>
            </method>
            <method name="toggleLockingImpl_">
                <body>
                <![CDATA[
                    if (!this.lockingStatus) return;
                    if (this.lockingStatus.controller && this.lockingStatus.controller.lock) {
                        this.lockingStatus.controller.lock();
                        this.selectNone();
                    } else if (this.lockingStatus.node) {
                        this.lockingStatus.node.removeAttributeNS(PencilNamespaces.p, "locked");
                        this.selectShape(this.lockingStatus.node);
                    }
                ]]>
                </body>
            </method>
            <method name="deleteSelected">
                <body>
                <![CDATA[
                    this.run(this.deleteSelectedImpl_, this);
                ]]>
                </body>
            </method>
            <method name="deleteSelectedImpl_">
                <body>
                <![CDATA[
                    this.currentController.deleteTarget();
                    this.currentController = null;
                    this._detachEditors();
                    this.clearSelection();
                ]]>
                </body>
            </method>
            <method name="_sayContentModified">
                <body>
                <![CDATA[
                    Dom.emitEvent("p:ContentModified", this);
                ]]>
                </body>
            </method>
            <method name="_saveMemento">
                <body>
                <![CDATA[
                    this.careTaker.save();
                ]]>
                </body>
            </method>
            <method name="getMemento">
                <body>
                <![CDATA[
                    return new CanvasMemento(this.drawingLayer.cloneNode(true), {});
                ]]>
                </body>
            </method>
            <method name="setMemento">
                <parameter name="memento"/>
                <body>
                <![CDATA[
                    this.selectNone();
                    Dom.empty(this.drawingLayer);

                    //alert("copy back: " + memento.node.childNodes.length + " nodes");
                    var fragment = this.drawingLayer.ownerDocument.createDocumentFragment();
                    for (var i = 0; i < memento.node.childNodes.length; i ++) {
                        fragment.appendChild(this.drawingLayer.ownerDocument.importNode(memento.node.childNodes[i], true));
                    }
                    this.drawingLayer.appendChild(fragment);
                    
                    this.focusableBox.style.visibility = "hidden";
                    this.focusableBox.style.visibility = "visible";
                    
                    this._sayContentModified();
                ]]>
                </body>
            </method>
            <method name="run">
                <parameter name="job"/>
                <parameter name="targetObject"/>
                <parameter name="args"/>
                <body>
                <![CDATA[
                    
                    try {
                        //console.log();
                        job.apply(targetObject, args);
                    } finally {
                        this._saveMemento();
                        this._sayContentModified();
                    }
                ]]>
                </body>
            </method>
            <method name="setSize">
                <parameter name="width"/>
                <parameter name="height"/>
                <body>
                <![CDATA[
                    this.width = width;
                    this.height = height;
                    
                    var thiz = this;
                    
                    this.svg.setAttribute("width", 10);
                    this.svg.setAttribute("height", 10);
                    
                    window.setTimeout(function () {
                        thiz.svg.setAttribute("width", Math.ceil(thiz.width * thiz.zoom));
                        thiz.svg.setAttribute("height", Math.ceil(thiz.height * thiz.zoom));
                        
                        CanvasImpl.setupGrid.apply(thiz);
                    }, 50);
                    
                ]]>
                </body>
            </method>
            <method name="setBackgroundImageData">
                <parameter name="image"/>
                <parameter name="dimBackground"/>
                <body>
                <![CDATA[
                    if (!image) {
                        this.backgroundImage.setAttributeNS(PencilNamespaces.xlink, "xlink:href", "");
                        this.backgroundImage.style.display = "none";
                        this.hasBackgroundImage = false;
                        this.removeAttributeNS(PencilNamespaces.p, "with-background");
                        return;
                    }
                    this.backgroundImage.setAttributeNS(PencilNamespaces.xlink, "xlink:href", image.url);
                    this.backgroundImage.setAttribute("width", image.width);
                    this.backgroundImage.setAttribute("height", image.height);
                    this.backgroundImage.style.display = "";
                    this.hasBackgroundImage = true;
                    this.setAttributeNS(PencilNamespaces.p, "p:with-background", "true");
                    if (!dimBackground) {
                        this.removeAttributeNS(PencilNamespaces.p, "with-background-dimmer");
                    } else {
                        this.setAttributeNS(PencilNamespaces.p, "p:with-background-dimmer", "true");
                    }
                ]]>
                </body>
            </method>
            <method name="setDimBackground">
                <parameter name="dimBackground"/>
                <body>
                <![CDATA[
                    if (!dimBackground) {
                        this.removeAttributeNS(PencilNamespaces.p, "with-background-dimmer");
                    } else {
                        this.setAttributeNS(PencilNamespaces.p, "p:with-background-dimmer", "true");
                    }
                ]]>
                </body>
            </method>
            <method name="sizeToContent">
                <parameter name="hPadding"/>
                <parameter name="vPadding"/>
                <body>
                <![CDATA[
                    this.zoomTo(1.0);
                    
                    var thiz = this;
                    var maxBox = null;
                    Dom.workOn("./svg:g[@p:type]", this.drawingLayer, function (node) {
                        try {
                            var controller = thiz.createControllerFor(node);
                            var bbox = controller.getBoundingRect();
                            var box = {
                                x1: bbox.x,
                                y1: bbox.y,
                                x2: bbox.x + bbox.width,
                                y2: bbox.y + bbox.height
                            };
                            if (maxBox == null) {
                                maxBox = box;
                            } else {
                                maxBox = {
                                    x1: Math.min(maxBox.x1, box.x1),
                                    y1: Math.min(maxBox.y1, box.y1),
                                    x2: Math.max(maxBox.x2, box.x2),
                                    y2: Math.max(maxBox.y2, box.y2)
                                };
                            }
                        } catch (e) {
                            alert(e);
                        }
                    });
                    if (maxBox == null) {
                        alert("The current document is empty, sizing is failed!");
                        return;
                    }
                    
                    var width = maxBox.x2 - maxBox.x1 + 2 * hPadding;
                    var height = maxBox.y2 - maxBox.y1 + 2 * vPadding;
                    
                    //moving
                    var dx = 0 - maxBox.x1 + hPadding;
                    var dy = 0 - maxBox.y1 + vPadding;
                    
                    Dom.workOn("./svg:g[@p:type]", this.drawingLayer, function (node) {
                        try {
                            var controller = thiz.createControllerFor(node);
                            var bbox = controller.getBoundingRect();
                            controller.moveBy(dx, dy);
                        } catch (e) {
                            alert(e);
                        }
                    });
                    
                    this.setSize(width, height);
                    
                    this.selectNone();
                    
                    return {width: width, height: height};
                ]]>
                </body>
            </method>
        </implementation>
        <handlers>
            <handler event="dragover">
                <![CDATA[
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                    this.lastAcceptedDragObserver = null;
                    for (var i in this.dragObservers) {
                        var observer = this.dragObservers[i];
                        try {
                            var accepted = nsDragAndDrop.dragOver(event, observer);
                            if (accepted) {
                                this.lastAcceptedDragObserver = observer;
                                break;
                            }
                        } catch (e) {}
                    }
                ]]>
            </handler>
            <handler event="dragdrop">
                <![CDATA[
                    netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
                    if (this.lastAcceptedDragObserver) {
                        try {
                            nsDragAndDrop.drop(event, this.lastAcceptedDragObserver);
                        } catch (e) {}
                    }
                ]]>
            </handler>
        </handlers>
        <xbl:content xmlns:xbl="http://www.mozilla.org/xbl"
                 xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
            <popupset>
                <popup aid="contextPopup">
                    <menu label="Arrangement" aid="arrangementMenu" p:for="Shape,TargetSet">
                        <menupopup>
                            <menuitem label="Bring to Front" oncommand="this.parentNode.parentNode._controller.bringToFront()"/>
                            <menuitem label="Bring Forward" oncommand="this.parentNode.parentNode._controller.bringForward()"/>
                            <menuitem label="Send Backward" oncommand="this.parentNode.parentNode._controller.sendBackward()"/>
                            <menuitem label="Send to Back" oncommand="this.parentNode.parentNode._controller.sendToBack()"/>
                        </menupopup>
                    </menu>
                    <menuseparator aid="contextPopupSeparator"/>
                    <menuitem aid="lockingMenuItem" label="Locked" type="checkbox" oncommand="this._canvas.toggleLocking();"/>
                    <menuseparator/>
                    <menuitem label="Group" command="groupCommand" p:for="TargetSet" key="groupKey"/>
                    <menuitem label="Ungroup" command="unGroupCommand" p:for="Group" key="unGroupKey"/>
                    <menuitem label="Delete" p:for="Shape,TargetSet,Group" oncommand="this._canvas.deleteSelected();"/>
                    <menuitem aid="propertyMenuItem" label="Properties..." p:for="Shape,Group,TargetSet"/>
                </popup>
            </popupset>
        </xbl:content>
    </binding>
</bindings>



